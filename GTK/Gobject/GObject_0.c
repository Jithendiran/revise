// my_object.c
#include <glib-object.h>

// Define MyObject and MyObjectClass
typedef struct _MyObject {
    GObject parent_instance;
    int some_data; // prefer gint
} MyObject;

typedef struct _MyObjectClass {
    GObjectClass parent_class;
    void (*do_something)(MyObject *self);
} MyObjectClass;

static void my_object_do_something(MyObject *self) {
    g_print("Doing something in MyObject: %d\n",self->some_data);
}

// do we need both GObject and GObjectClass?
/*
GObject requires both class and instance structures to implement class-level and instance-level behavior.
| Part                | Purpose                                              |
| ------------------- | ---------------------------------------------------- |
| Instance Struct     | Holds data (fields) for each object                  |
| Class Struct        | Holds methods and shared config for the type         |

Instance stores == Object state
    Every object you create (via g_object_new) has its own instance struct on the heap.
    It stores:
    * Per-object data (e.g., a counter, a name, etc.)
    * A hidden pointer to its class (used for calling methods)
Each MyObject can store a different value of some_data.
    
Class struct == Object behavior
    Each type (like MyObject) has one class struct shared across all its instances.
    It stores:
    * Virtual function pointers (methods)
    * Class-wide data (static configuration)
All MyObject instances share the same class struct. If you override a method at runtime, this is where you do it.
*/

G_DEFINE_TYPE(MyObject, my_object, G_TYPE_OBJECT) 
// what this do?
/*
This is a macro that generates a bunch of boilerplate code to register your type with GObject.
my_object is the prefix we give
*/

// Class init, Runs once for class setup.
static void my_object_class_init(MyObjectClass *klass) {
    g_print("MyObjectClass initialized\n");
    // assign the function 
    klass->do_something = my_object_do_something;
}

// Instance init, Runs for each instance.
static void my_object_init(MyObject *self) {
    g_print("MyObject instance initialized\n");
    self->some_data = 42;
}

// getters and setters
gint my_object_get_some_data(MyObject *self) {
    g_return_val_if_fail(self != NULL, -1);  // Runtime check
    return self->some_data;
}

void my_object_set_some_data(MyObject *self, gint value) {
    g_return_if_fail(self != NULL);  // Runtime check
    self->some_data = value;
}

int main() {
    // what is my_object_get_type?
    /*
    This is a function generated by G_DEFINE_TYPE(...).
    Registers the type if not already registered.
    Returns the unique GType ID for your class.
    */
    // g_object_new?
    /*
    This is like new in C++ or Java:
    Allocates memory on the heap.
    Calls my_object_init().

    */
    // where *obj will be stored in heap or stack?
    MyObject *obj = g_object_new(my_object_get_type(), NULL); 
    /*OP
    MyObjectClass initialized
    MyObject instance initialized
    */

    // Access the class struct of MyObject
    MyObjectClass *klass = G_TYPE_INSTANCE_GET_CLASS(obj, my_object_get_type, MyObjectClass);

    // Call the virtual function (if it's assigned)
    if (klass->do_something != NULL) {
        klass->do_something(obj);
        // Doing something in MyObject : 42
    }

    // Use setter to change value
    my_object_set_some_data(obj, 99);

    // Use getter to retrieve it
    gint val = my_object_get_some_data(obj);
    g_print("New some_data: %d\n", val);  // New some_data: 99


    // g_object_unref?
    /*
    This decreases the reference count of the object.
    GObject uses reference counting for memory management. When the count reaches 0, it is automatically freed.
    */
    g_object_unref(obj);
    return 0;
}

// gcc GObject_0.c `pkg-config --cflags --libs gobject-2.0` -o /tmp/my_object